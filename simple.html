<!DOCTYPE html>

<html>
<style>
body{background-color: #808080}
</style>
	<head>
		<script
			src="https://threejs.org/build/three.js">
		</script>
		<script
			src="https://threejs.org/examples/js/controls/TrackballControls.js">
		</script>
	</head>
	<body>
		<div align="center" style="background-color:white">
			<big><big>EmerGenTium&trade;</big></big><br/>
			<small>
				Copyright&copy;2018 Jonathan D. Lettvin, All Rights Reserved
			</small><br/>
		</div>
	</body>
	<script type="text/javascript">

/////////////////////////////////////////
// Scene Setup
/////////////////////////////////////////

(function(doc,win) {
	// TODO
	// isize doesn't work, but perhaps we can do this all with opacity.

	doc.jlettvin = doc.jlettvin || {};
	doc.jlettvin.scrimmage = doc.jlettvin.scrimmage || {};

	var winW          = win.innerWidth;
	var winH          = win.innerHeight;

	// Orthogonal distances to original camera position
	var Acamera       = 6.5;

	function create(Rx=10, Ry=10, Rz=3) {
		// Scalars to guarantee fitting nodes within window
		var range         = 5e-1;
		var edge          = range / 2;

		// Radial count of nodes along each axis beyond center
		var RX            = Rx;
		var RY            = Ry;
		var RZ            = Rz;  // Never less than 2 while PlaneP/PlaneN testing
		// Counts of nodes along each axis (including 1 extra for center)
		var DX            = 1 + 2 * RX;
		var DY            = 1 + 2 * RY;
		var DZ            = 1 + 2 * RZ;
		// Count of lattice vertices
		var N             = DX * DY * DZ;
		// Use largest of radii to scale nodes to fit within window and axes
		var shrinkToFit   = 1 / Math.max(RX, Math.max(RY, RZ));
		var size          = shrinkToFit * edge;

		var lattice       = []; // linear array of node objects
		doc.jlettvin.scrimmage.lattice = lattice;
		//var sizes         = []; // node cube size array
		var axis          = [   // ndarray-style summable axes
			new Int32Array(DX),
			new Int32Array(DY),
			new Int32Array(DZ),
		];
		var i, j, k;            // loop indices

		// Now instance global THREE resources
		var scene         = new THREE.Scene();
		var camera        = new THREE.PerspectiveCamera(10, winW / winH, 1, 1000);
		var renderer      = new THREE.WebGLRenderer({alpha: true, antialias: true});
		var controls      = new THREE.TrackballControls(camera);
		var ambientLight  = new THREE.AmbientLight('#EEEEEE');
		var axisHelper    = new THREE.AxesHelper(1.25);
		var nodeObject    = new THREE.Object3D();
		var bufGeom       = new THREE.BufferGeometry();
		var allGeom       = new THREE.CubeGeometry(size, size, size);

		camera.position.set(Acamera, Acamera, Acamera);
		camera.lookAt(scene.position);

		// Fit doc element into window without scrollbars
		renderer.setSize(0.95 * winW, 0.95 * winH);
		renderer.setPixelRatio(win.devicePixelRatio);

		// How the trackball controls work
		Object.assign(controls,{
			rotateSpeed          : 5.0,
			zoomSpeed            : 3.2,
			panSpeed             : 0.8,
			noZoom               : false,
			noPan                : true,
			staticMoving         : false,
			dynamicDampingFactor : 0.2,
		});

		// When to update
		controls.addEventListener('change', renderLattice);

		// window resize
		win.addEventListener('resize', function () {
			winW          = win.innerWidth;
			winH          = win.innerHeight;
			camera.aspect = winW / winH;

			camera.updateProjectionMatrix();
			renderer.setSize(winW*shrinkToFit, winH*shrinkToFit);
			controls.handleResize();
			renderLattice();
		}, false);

		// Generate axes for conversion from (x,y,z) to global index
		for(k = 0; k <= DZ; ++k) { axis[2][k] = k * DY * DX; }
		for(j = 0; j <= DY; ++j) { axis[1][j] = j *      DX; }
		for(i = 0; i <= DX; ++i) { axis[0][i] = i          ; }


		// Construct lattice and indexable lattice list
		bufGeom.fromGeometry(allGeom);
		for(k = -RZ; k <= RZ; ++k) {
			var z = shrinkToFit * k;
			var planeP   = (k == -2);
			var planeN   = (k == -1);
			var scale = (planeP || planeN) ? 1.0 : 0.5;
			var size = shrinkToFit * scale * edge;
			var material = (planeP || planeN) ?
				{transparent: true, opacity: 0.75} :
				{transparent: true, opacity: 0.25} ;
			for(j = -RY; j <= RY; ++j) {
				var y = shrinkToFit * j;
				for(i = -RX; i <= RX; ++i) {
					//sizes.push(size);
					var x = shrinkToFit * i;
					var grayness = planeP ? 0.0 :
						(planeN ? 1.0 :  Math.random() * 0.5 + 0.25);
					var nodeMaterial = new THREE.MeshLambertMaterial(material);
					var node         = new THREE.Mesh(bufGeom, nodeMaterial);
					nodeMaterial.color.setRGB(grayness, grayness, grayness);
					node.position.set(x*range, y*range, z*range);
					//node.grayness = grayness; // *** NOTE THIS
					nodeObject.add(node);
					lattice.push(node);
				}
			}
		}
		/*
		// After filling size array, make available as a geometry attribute
		bufGeom.addAttribute(
			'size',
			new THREE.Float32BufferAttribute(sizes, 1).setDynamic(true));
		 */

		// Give (x,y,z) of center, and test conversions back and forth to index
		var theCenter  = [0,0,0];
		var iCenter = xyz2i(theCenter);
		var xyzCenter = i2xyz(iCenter);
		//console.log("XYZ:", theCenter, " == ", xyzCenter);

		// Observe node at (0,0,0) and make access simpler
		//console.log("NODE(0,0,0):", lattice[iCenter]);

		/*
			// Change the node size
	function isize(i, want) {
	// Returns the previous values
		var node = lattice[i];
		var geom = node.geometry;
		var sizes = geom.attributes.size.array;
		var old  = sizes[i];
	// TODO This doesn't work
		sizes[i] = want;
		geom.attributes.size.needsUpdate = true;
		return old
	}
		// Test control of node size
	isize(iCenter, 2);  // TODO This doesn't work (see isize)
		 */

		// Change the node color/opacity
		function irgba(i, rgb, a) {
			// Returns the previous values
			var node     = document.jlettvin.scrimmage.lattice[i];
			var material = node.material;
			var color    = material.color;
			var opacity  = material.opacity;
			var old      = [color.r, color.b, color.b, opacity];

			//console.log("NODE-(",i,"):",node);
			Object.assign(color, rgb);
			material.opacity = a;
			material.needsUpdate = true;
			//console.log("NODE+(",i,"):",node);

			return old;
		}
		// Test control of node color
		irgba(iCenter, {r:1, g:0, b:0}, 1);


		// Convert coordinates to index
		function xyz2i(xyz) {
			return axis[0][xyz[0]+RX] + axis[1][xyz[1]+RY] + axis[2][xyz[2]+RZ];
		}

		// Convert index to coordinates
		function i2xyz(i) { // ~~(foo%bar) gives the integer modulus
			var x = ~~(i % DX) - RX; i /= DX;
			var y = ~~(i % DY) - RY; i /= DY;
			var z = ~~(i     ) - RZ;
			return [x,y,z];
		}

		function animationLoop() {
			requestAnimationFrame(animationLoop);
			controls.update();
		}

		function renderLattice() { renderer.render(scene, camera); }

		scene.add(ambientLight);
		scene.add(axisHelper);
		scene.add(nodeObject);

		doc.body.appendChild(renderer.domElement);

		animationLoop();

		doc.jlettvin.scrimmage.irgba   =   irgba;
		doc.jlettvin.scrimmage.xyz2i   =   xyz2i;
		doc.jlettvin.scrimmage.i2xyz   =   i2xyz;
	}
	doc.jlettvin.scrimmage.create = create;
})(document,window);

	var scrimmage = document.jlettvin.scrimmage;
	scrimmage.create(10, 10, 5);
	var iAnother = scrimmage.xyz2i[0,0,1];
	//scrimmage.irgba(iAnother,{r:0, g:1, b:0},1);
	</script>
</html>
